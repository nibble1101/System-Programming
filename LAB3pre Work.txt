             LAB3pre Work: Processes in an OS Kernel                     DUE: 9-23-2021       Answer questions below. Submit a (text-edit) file to TA				Submitted by: Ritik Agarwal	     1. READ List: Chapter 3: 3.1-3.5What's a process? (Page102)The process can be defined as a task performed by the operating system. A process is the execution of the image of the OS Kernel. An execution image is the memory area containing the code, data, and stack. Further a process can be defined as the sequence of the executions by the OS Kernel as a single entity for using the system resources.	     Each process is represented by a PROC structure.Read the PROC structure in 3.4.1 on Page 111 and answer the following questions:What's the meaning of:pidpid: Process ID.ppid?ppid: Parent Process ID.   status?status stores the current status of the process. Status can be Free, Ready Sleep, Zombie.   event? The event field in the PROC Structure is used to mark the running process as sleep to synchronize different processes together. There might be instances where a process requires some action to be done which depends on the completion of the other process. In such case we can put the process to sleep by updating the event value of the PROC structure to sleep.    exitCode?Each PROC has an exitCode field, which is the process exitValue when it terminates.READ 3.5.2 on Process Family Tree. What are the   PROC pointers child, sibling, parent used for?______________________________	     2. Download samples/LAB3pre/mtx. Run it under Linux.   MTX is a multitasking system. It simulates process operations in a   Unix/Linux kernel, which include              fork, exit, wait, sleep, wakeup, process switching	     /*********** A Multitasking System ************/#include <stdio.h>#include <stdlib.h>#include <string.h>#include "type.h"    // PROC struct and system constants	// global variables:PROC proc[NPROC], *running, *freeList, *readyQueue, *sleepList; running    = pointer to the current running PROCfreeList   = a list of all FREE PROCsreadyQueue = a priority queue of procs that are READY to runsleepList  = a list of SLEEP procs, if any.Run mtx. It first initialize the system, creates an initial process P0.P0 has the lowest priotiry 0, all other processes have priority 1Ater initialization,     P0 forks a child prcoess P1, switch process to run P1.                The display looks like the following-----------------------------------------------------------------------------Welcome to KCW's Multitasking System1. init systemfreeList = [0 0]->[1 0]->[2 0]->[3 0]->[4 0]->[5 0]->[6 0]->[7 0]->[8 0]->NULL2. create initial process P0init complete: P0 running3. P0 fork P1 : enter P1 into readyQueue	     4. P0 switch process to run P1   P0: switch task   proc 0 in scheduler()   readyQueue = [1 1]->[0 0]->NULL   next running = 1   proc 1 resume to body()proc 1 running: Parent=0 childList = NULLfreeList  = [2 0]->[3 0]->[4 0]->[5 0]->[6 0]->[7 0]->[8 0]->NULLreadQueue = [0 0]->NULLsleepList = NULLinput a command: [ps|fork|switch|exit|sleep|wakeup|wait] : ----------------------------------------------------------------------------5.                     COMMANDS:ps     : display procs with pid, ppid, status; same as ps in Unix/Linuxfork   : READ kfork()   on Page 109: What does it do?The kfork() forks the current process and creates a child process and enqueue it into the readyQueue. kfork(), we initialize the stack of the new task. When the new task starts to run, it begins by executing the RESUME part of tswitch(), which causes it to return to the entry address of the body() function.switch : READ tswitch() on Page 108: What does it do?The role of the tswitch() function is context switching. When the program calls the tswitch(), the process changes to other process from the readyqueue.exit   : READ kexit()   on Page 112: What does it do?The role of the kexit() is to exit from a process. The kexit() does the following: Erase process user-mode context, Dispose of children processes, Record exitValue in PROC.exitCode for parent to get, Become a ZOMBIE and Wakeup parent and, if needed, also the INIT process P1.         sleep  : READ ksleep()  on Page 111: What does it doWhen a process requires another process to complete, it goes in the sleep mode. The ksleep() implements the sleeping functionality. It does the following: record event value in PROC.event, change status to SLEEP, for ease of maintenance, enter caller into a PROC *sleepList.wakeup : READ kwakeup() on Page 112: What does it do?The role of the kwakeup() is to instantiate the sleeping processes from the sleepList and enqueue them in the readyQueue.	     wait   : READ kwait()   on Page 114: What does it do?At any time, a process may call the kernel function to wait for a ZOMBIE child process. If successful, the returned pid is the ZOMBIE child's pid andstatus contains the exitCode of the ZOMBIE child. In addition, kwait() also releases the ZOMBIE child PROC back to the freeList for reuse.--------------------------------------------------------------------------------------------------- TEST REQUIREMENTS ---------------------------------6. Step 1: test forkWhile P1 running, enter fork: What happens?A child process is created with the pid as 2 and ppid as 1. The readyqueque now has two processes with pid as 0 and 1.Enter fork many times; How many times can P1 fork?The P1 can fork 7 times. It’s due to the reason that there are only 7 free process available which were all used up in forking 7 times.Enter Control-c to end the program run.7. Step 2: Test sleep/wakeupRun mtx again.While P1 running, fork a child P2;Switch to run P2. Where did P1 go?P1 went in the scheduler as it will wait for P2 to end and then it will resume.P2 running : Enter sleep, with a value, e.g.123 to let P2 SLEEP.What happens?The P2 is sent to the sleepList with an event value. It will wait for the event to complete and then it will resume.Now, P1 should be running. Enter wakeup with a value, e.g. 234Did any proc wake up?No, P2 did not wakeup as the event value stored is different than the value entered at the time it was sent to sleep.P1: Enter wakeup with 123What happens?Now the P2 has been woken up and is sent to the readyQueue and is ready to be executed.8. Step 3: test child exit/parent wait	     When a proc dies (exit) with a value, it becomes a ZOMBIE, wakeup its parent.Parent may issue wait to wait for a ZOMBIE child, and frees the ZOMBIERun mtx;P1: enter wait; What happens?A wait error was displayed as there was no child of the process P1.CASE 1: child exit first, parent wait laterP1: fork a child P2, switch to P2.P2: enter exit, with a value, e.g. 123 ==> P2 will die with exitCode=123.Which process runs now?Now, the P1 is running. The P2 has been added in the child list as a zombie. enter ps to see the proc status: P2 status = Zombie(P1 still running) enter wait; What happens?P1 waits for the zombie child to exit and then it removes the zombie from the childList. Now, the P1 resumes.                   enter ps;   What happened to P2? FreeCASE 2: parent wait first, child exit laterP1: enter fork to fork a child P3P1: enter wait;  What happens to P1? The P1 looks for the zombie child processes to end. But since there were no children, it went to sleep and now P3 is running.P3: Enter exit with a value; What happens?The process gives away its children to P1. Now the P1 is waiting for the zombie child P3. Now, the P1 is running.P1: enter ps; What’s the status of P3? Free because it was never existed.	     9. Step 4: test Orphans	     When a process with children dies first, all its children become orphans.In Unix/Linux, every process (except P0) MUST have a unique parent.So, all orphans become P1's children. Hence P1 never dies.Run mtx again.P1: fork child P2, Switch to P2.P2: fork several children of its own, e.g. P3, P4, P5 (all in its childList).P2: exit with a value. P1 should be running WHY?P1 is running because it was present in the readyQueue list waiting for its execution after the exit of P2.P1: enter ps to see proc status: which proc is ZOMBIE?P2 is Zombie.What happened to P2's children?All the children of P2 became the children of P1 as they were grandchildren of P1.P1: enter wait; What happens? The zombie process that is P2 exits.P1: enter wait again; What happens?The P3 starts running and all the child of P1 becomes ready to be executed in the readyQueue. The P1 is in the sleepList and waiting for its children execution to be completed.How to let P1 READY to run again?P1 will be ready to run again after all its children processes run and exit.  